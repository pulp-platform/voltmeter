#!/usr/bin/env python3

# Copyright 2023 ETH Zurich and University of Bologna.
# Licensed under the Apache License, Version 2.0, see LICENSE for details.
# SPDX-License-Identifier: Apache-2.0
#
# Author: Sergio Mazzola, ETH Zurich <smazzola@iis.ee.ethz.ch>

import os
import yaml
import copy

# define expected YAML syntax
config_syntax = {
    'param-platform': {},
    'param-profiler': {},
    'arguments': {
        'events': None,
        'config_cpu': None,
        'config_gpu': None,
        'cli_cpu': None,
        'cli_gpu': None,
        'mode': None,
        'trace_dir': None,
        'benchmarks': [
            {
                'name': True, # True means required
                'path': True,
                'args': None  # None means optional
            }
        ],
    }
}

if __name__ == '__main__':
    # input
    CONFIG_YML = os.getenv('VOLTMETER_YML')
    # outputs
    OUTPUT_MK = os.getenv('VOLTMETER_MK')

    if CONFIG_YML is None:
        raise Exception('VOLTMETER_YML not set')
    if OUTPUT_MK is None:
        raise Exception('VOLTMETER_MK not set')

    # get config from YAML file
    with open(CONFIG_YML, 'r') as f:
        config_yml = yaml.safe_load(f)
    # verify config syntax (top-level)
    for key in config_syntax:
        if key not in config_yml:
            raise Exception('Invalid {}: key \'{}\' not found'.format(CONFIG_YML, str(key)))
        if type(config_yml[key]) is not type(config_syntax[key]):
            raise Exception('Invalid {}: key \'{}\' must be of type \'{}\''.format(CONFIG_YML, str(key), str(type(config_syntax[key]))))
    # check that there are no unexpected keys
    for key in config_yml:
        if key not in config_syntax:
            raise Exception('Invalid {}: key {} not expected'.format(CONFIG_YML, str(key)))
    # not too many checks on the arguments (left to the voltmeter executable itself)
    # verify config syntax (benchmarks list)
    for item in config_yml['arguments']['benchmarks']:
        # verify all required keys are present
        for key in config_syntax['arguments']['benchmarks'][0]:
            if (key not in item) and (config_syntax['arguments']['benchmarks'][0][key] is True):
                # only complain for not found key if it is a required key (i.e., True)
                raise Exception('Invalid {}: key \'{}\' not found'.format(CONFIG_YML, str(key)))
        # verify there are no unexpected keys
        for key in item:
            if key not in config_syntax['arguments']['benchmarks'][0]:
                raise Exception('Invalid {}: key \'{}\' not expected'.format(CONFIG_YML, str(key)))

    # process config
    config = copy.deepcopy(config_yml)
    for key in config_yml['arguments']:
        # remove empty arguments
        if config_yml['arguments'][key] is None:
            del config['arguments'][key]
        # convert paths to absolute
        if key in ['config_cpu', 'config_gpu', 'trace_dir']:
            config['arguments'][key] = os.path.abspath(config_yml['arguments'][key])
    # process benchmarks
    for b in config['arguments']['benchmarks']:
        for key in b:
            b[key] = str(b[key])
        # if benchmark key is not found and it is optional, set it to None
        for key in config['arguments']['benchmarks'][0]:
            if (key not in b) and (config['arguments']['benchmarks'][0][key] is None):
                b[key] = None
        # convert paths to absolute
        b['path'] = os.path.abspath(b['path'])
        # comma-separated arguments
        if b['args'] is not None:
            # if argument does not contain any ',' then replace all spaces with ','
            if ',' not in b['args']:
                b['args'] = b['args'].replace(' ', ',')
            else:
                raise Exception('Invalid {}: benchmark arguments must not contain \',\''.format(CONFIG_YML))

    # generate makefrag
    # very much care was taken to make sure that each couple path+args is recognized as a
    # single string by the shell so that it is passed as a whole to voltmeter; at the same
    # time, also the benchmark arguments are passed as a whole to the flag --benchmark_args
    with open(OUTPUT_MK, 'w') as f:
        f.write('# This file is automatically generated by scripts/parse_config.py\n\n')
        f.write('# Voltmeter compilation parameter\n')
        for key in [k for k in config if k != 'arguments']:
            for param in config[key]:
                f.write('{} := {}\n'.format(param, config[key][param]))
        f.write('\n')
        f.write('# Voltmeter CLI arguments\n')
        for key in [k for k in config['arguments'] if k != 'benchmarks']:
            f.write('VOLTMETER_ARGS += --{} {}\n'.format(key, config['arguments'][key]))
        f.write('# Benchmarks\n')
        # passed as a string to the shell (i.e., surrounded by ''); a shell 'for' loop can
        # differentiate the different iterable elements thanks to the character '\n'; thanks
        # to this, the "" can be used to keep the arguments of --benchmark_args as a whole
        # the '\\\n' are only used to make the voltmeter.mk more readable
        f.write('BENCHMARKS := $$\' \\\n')
        for b in config['arguments']['benchmarks'][:-1]:
            f.write('\t--benchmark={}'.format(b['path']))
            if b['args'] is not None:
                f.write(' --benchmark_args={}'.format(b['args']))
            f.write('\\n \\\n')
        # last element
        b = config['arguments']['benchmarks'][-1]
        f.write('\t--benchmark={}'.format(b['path']))
        if b['args'] is not None:
            f.write(' --benchmark_args={}'.format(b['args']))
        f.write(' \\\n\'\n')
